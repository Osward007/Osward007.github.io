<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>äº¤äº’å¼å›¾æ¡ˆ</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #000000; height: 100vh; display: flex;
            justify-content: center; align-items: center; overflow: hidden; position: relative;
        }
        .container {
            position: relative; width: 300px; height: 300px;
            display: flex; justify-content: center; align-items: center;
        }
        .center-pattern {
            width: 100%; height: 100%; border-radius: 50%;
            background: url('./image/IMG_4397.png') center/cover no-repeat;
            cursor: pointer; position: relative; z-index: 10; transition: opacity 0.3s;
        }
        .arrow {
            position: absolute; width: 50px; height: 50px; z-index: 5; opacity: 0.9;
            animation: move-towards-center 0.6s infinite ease-in-out;
            transform-origin: center; margin-left: -25px; margin-top: -25px;
        }
        .arrow svg { width: 100%; height: 100%; }
        .arrow svg path { stroke: #833B1A; stroke-width: 3; }
        @keyframes move-towards-center {
            0% { transform: translate(0, 0) rotate(var(--rotation)); }
            50% { transform: translate(calc(-10px * var(--dx)), calc(-10px * var(--dy))) rotate(var(--rotation)); }
            100% { transform: translate(0, 0) rotate(var(--rotation)); }
        }
        .animation-container {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            display: none; justify-content: center; align-items: center;
            z-index: 20; pointer-events: none;
        }
        .animation-frame {
            position: absolute; background-size: contain;
            background-repeat: no-repeat; background-position: center;
            opacity: 0; transition: opacity 0.05s;
        }
        @media (max-width: 768px) {
            .container { width: 200px; height: 200px; }
            .arrow { width: 35px; height: 35px; margin-left: -17.5px; margin-top: -17.5px; }
        }
    </style>
</head>
<body>
    <div class="container"><div class="center-pattern" id="centerPattern"></div></div>
    <div class="animation-container" id="animationContainer"></div>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const container = document.querySelector('.container');
            const centerPattern = document.getElementById('centerPattern');
            const animationContainer = document.getElementById('animationContainer');
            const animationConfig = {
                totalFrames: 38, fps: 30, firstGroupFrames: 19,
                secondGroupFrames: 19, originalSize: 2048, animationSize: 3000
            };
            const frameTimingConfig = { 19: 200, 37: 1000 };
            const scaleRatio = animationConfig.animationSize / animationConfig.originalSize;
            const baseFrameInterval = 1000 / animationConfig.fps;
            
            // ==================== ã€æ ¸å¿ƒä¿®å¤ã€‘æ™ºèƒ½åŠ è½½å™¨ ====================
            function createSmartImageLoader() {
                let queue = [];
                let isProcessing = false;
                const loadedImages = [];
                
                function processQueue() {
                    if (isProcessing || queue.length === 0) return;
                    
                    isProcessing = true;
                    const { src, resolve, retryCount = 0 } = queue.shift();
                    const filename = src.split('/').pop();
                    
                    console.log(`ğŸ“¥ åŠ è½½: ${filename} (è¿˜æœ‰ ${queue.length} ä¸ªç­‰å¾…)`);
                    
                    const img = new Image();
                    img.crossOrigin = 'anonymous';
                    
                    // é¿å…GitHubç¼“å­˜ï¼šæ¯æ¬¡è¯·æ±‚ä¸åŒURL
                    const uniqueSrc = src + (src.includes('?') ? '&' : '?') + 
                        `_t=${Date.now()}_${retryCount}`;
                    
                    img.onload = () => {
                        console.log(`âœ… ${filename} æˆåŠŸ (ç¬¬${retryCount + 1}æ¬¡å°è¯•)`);
                        loadedImages.push(img);
                        resolve(img);
                        isProcessing = false;
                        
                        // GitHubé™åˆ¶ï¼šæˆåŠŸåŠ è½½åç­‰å¾…800mså†åŠ è½½ä¸‹ä¸€å¼ 
                        setTimeout(processQueue, 800);
                    };
                    
                    img.onerror = () => {
                        if (retryCount < 2) { // æœ€å¤šé‡è¯•2æ¬¡
                            console.log(`ğŸ”„ ${filename} é‡è¯•ä¸­... (${retryCount + 1}/2)`);
                            
                            // æŒ‡æ•°é€€é¿ï¼š1ç§’ã€2ç§’
                            const delay = 1000 * (retryCount + 1);
                            setTimeout(() => {
                                queue.unshift({ 
                                    src, 
                                    resolve, 
                                    retryCount: retryCount + 1 
                                });
                                isProcessing = false;
                                processQueue();
                            }, delay);
                        } else {
                            console.warn(`âš ï¸ ${filename} æœ€ç»ˆå¤±è´¥ï¼Œè·³è¿‡`);
                            // åˆ›å»ºç©ºå›¾ç‰‡å ä½ï¼Œä¸é˜»å¡æµç¨‹
                            const emptyImg = new Image();
                            loadedImages.push(emptyImg);
                            resolve(emptyImg);
                            isProcessing = false;
                            setTimeout(processQueue, 300);
                        }
                    };
                    
                    img.src = uniqueSrc;
                }
                
                return {
                    add: (src) => {
                        return new Promise((resolve) => {
                            queue.push({ src, resolve });
                            processQueue();
                        });
                    },
                    getLoadedImages: () => loadedImages
                };
            }
            
            function preloadAnimationFrames() {
                console.log('ğŸš€ å¼€å§‹æ™ºèƒ½åŠ è½½38å¼ åŠ¨ç”»å¸§...');
                const loader = createSmartImageLoader();
                const promises = [];
                
                // ä¸­å¿ƒå›¾ç‰‡
                promises.push(loader.add('./image/IMG_4397.png'));
                
                // ç¬¬ä¸€ç»„ï¼šmimo0001.png åˆ° mimo0019.png
                console.log('ğŸ“¦ åŠ è½½ç¬¬ä¸€ç»„ï¼ˆmimo0001-mimo0019ï¼‰');
                for (let i = 1; i <= 19; i++) {
                    const frameNum = i.toString().padStart(4, '0');
                    promises.push(loader.add(`./image/mimo${frameNum}.png`));
                }
                
                // ç¬¬äºŒç»„ï¼šIMG_4403.png åˆ° IMG_4420.png
                console.log('ğŸ“¦ åŠ è½½ç¬¬äºŒç»„ï¼ˆIMG_4403-IMG_4420ï¼‰');
                for (let i = 3; i <= 20; i++) {
                    const frameNum = i.toString().padStart(2, '0');
                    promises.push(loader.add(`./image/IMG_44${frameNum}.png`));
                }
                
                return { 
                    frames: loader.getLoadedImages(), 
                    promises: Promise.all(promises) 
                };
            }
            // ==================== ä¿®å¤ç»“æŸ ====================
            
            function createArrows() {
                const containerRect = container.getBoundingClientRect();
                const arrowCount = 12;
                const centerX = containerRect.left + containerRect.width / 2;
                const centerY = containerRect.top + containerRect.height / 2;
                const patternRadius = containerRect.width / 2;
                document.querySelectorAll('.arrow').forEach(arrow => arrow.remove());
                
                for (let i = 0; i < arrowCount; i++) {
                    const angle = (i / arrowCount) * Math.PI * 2;
                    const dx = Math.cos(angle); 
                    const dy = Math.sin(angle);
                    const distanceFromCenter = patternRadius * 0.95;
                    const x = centerX + distanceFromCenter * dx;
                    const y = centerY + distanceFromCenter * dy;
                    
                    const arrow = document.createElement('div');
                    arrow.className = 'arrow';
                    arrow.style.position = 'fixed';
                    arrow.style.left = `${x}px`; 
                    arrow.style.top = `${y}px`;
                    
                    const rotation = Math.atan2(centerY - y, centerX - x) * (180 / Math.PI);
                    arrow.style.setProperty('--rotation', `${rotation}deg`);
                    arrow.style.setProperty('--dx', dx); 
                    arrow.style.setProperty('--dy', dy);
                    arrow.style.animationDelay = '0s';
                    
                    arrow.innerHTML = `<svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M5 12H19M19 12L12 5M19 12L12 19" stroke-linecap="round" stroke-linejoin="round"/></svg>`;
                    document.body.appendChild(arrow);
                }
            }
            
            function playAnimationSequence(frames) {
                console.log('ğŸ¬ å¼€å§‹æ’­æ”¾åŠ¨ç”»åºåˆ—...');
                
                // è¿‡æ»¤æ‰åŠ è½½å¤±è´¥çš„å›¾ç‰‡
                const validFrames = frames.filter(img => 
                    img.src && img.complete && img.naturalHeight > 0
                );
                
                console.log(`ğŸ“Š å¯ç”¨å›¾ç‰‡å¸§: ${validFrames.length}/38`);
                
                if (validFrames.length < 20) {
                    const warning = document.createElement('div');
                    warning.innerHTML = `
                        <div style="
                            position: fixed; top: 20px; left: 50%; transform: translateX(-50%);
                            background: rgba(255,100,100,0.9); color: white; padding: 15px;
                            border-radius: 10px; z-index: 100; text-align: center;
                            max-width: 80%; font-size: 14px; backdrop-filter: blur(5px);
                        ">
                            âš ï¸ åŠ¨ç”»ä¸å®Œæ•´ï¼šåªåŠ è½½äº† ${validFrames.length}/38 å¼ å›¾ç‰‡<br>
                            GitHubé™åˆ¶å¯¼è‡´éƒ¨åˆ†å›¾ç‰‡åŠ è½½å¤±è´¥
                        </div>
                    `;
                    document.body.appendChild(warning);
                    setTimeout(() => warning.remove(), 5000);
                }
                
                const containerRect = container.getBoundingClientRect();
                centerPattern.style.opacity = '0';
                centerPattern.style.pointerEvents = 'none';
                animationContainer.style.display = 'flex';
                
                let currentFrame = 0;
                
                function showFrame() {
                    animationContainer.innerHTML = '';
                    if (currentFrame >= validFrames.length) { 
                        console.log(`âœ¨ åŠ¨ç”»æ’­æ”¾å®Œæ¯• (ä½¿ç”¨äº† ${validFrames.length} å¼ å›¾ç‰‡)`); 
                        return; 
                    }
                    
                    const frameElement = document.createElement('div');
                    frameElement.className = 'animation-frame';
                    frameElement.style.width = `${containerRect.width}px`;
                    frameElement.style.height = `${containerRect.height}px`;
                    frameElement.style.backgroundImage = `url('${validFrames[currentFrame].src}')`;
                    frameElement.style.transform = `scale(${scaleRatio})`;
                    frameElement.style.opacity = '1';
                    animationContainer.appendChild(frameElement);
                    
                    let frameInterval = baseFrameInterval;
                    const originalIndex = frames.indexOf(validFrames[currentFrame]);
                    if (frameTimingConfig[originalIndex] !== undefined) {
                        frameInterval = frameTimingConfig[originalIndex];
                    }
                    
                    currentFrame++; 
                    setTimeout(showFrame, frameInterval);
                }
                showFrame();
            }
            
            const { frames, promises } = preloadAnimationFrames();
            let allFramesLoaded = false;
            
            promises.then(() => {
                allFramesLoaded = true;
                const loadedCount = frames.filter(img => 
                    img.src && img.complete && img.naturalHeight > 0
                ).length;
                console.log(`ğŸ‰ åŠ è½½å®Œæˆï¼æˆåŠŸ: ${loadedCount}/38 å¼ å›¾ç‰‡`);
            }).catch((error) => {
                console.warn('âš ï¸ åŠ è½½è¿‡ç¨‹ä¸­å‡ºç°é”™è¯¯:', error);
                allFramesLoaded = true;
            });
            
            createArrows();
            let isClicked = false;
            
            centerPattern.addEventListener('click', function() {
                if (!isClicked) {
                    console.log('ğŸ–±ï¸ ç‚¹å‡»è§¦å‘åŠ¨ç”»æ’­æ”¾');
                    const arrows = document.querySelectorAll('.arrow');
                    arrows.forEach(arrow => {
                        arrow.style.transition = 'opacity 0.3s, transform 0.3s';
                        arrow.style.opacity = '0'; 
                        arrow.style.transform = 'scale(0.5)';
                        setTimeout(() => { arrow.style.display = 'none'; }, 300);
                    });
                    
                    if (allFramesLoaded) {
                        playAnimationSequence(frames);
                    } else {
                        console.log('â³ ç­‰å¾…å›¾ç‰‡åŠ è½½å®Œæˆ...');
                        const loadingMsg = document.createElement('div');
                        loadingMsg.textContent = 'åŠ è½½åŠ¨ç”»å›¾ç‰‡ä¸­...';
                        loadingMsg.style.color = 'white'; 
                        loadingMsg.style.position = 'fixed';
                        loadingMsg.style.top = '50%'; 
                        loadingMsg.style.left = '50%';
                        loadingMsg.style.transform = 'translate(-50%, -50%)';
                        loadingMsg.style.zIndex = '30'; 
                        loadingMsg.style.fontSize = '20px';
                        loadingMsg.style.background = 'rgba(0,0,0,0.8)';
                        loadingMsg.style.padding = '20px'; 
                        loadingMsg.style.borderRadius = '10px';
                        document.body.appendChild(loadingMsg);
                        
                        const checkInterval = setInterval(() => {
                            if (allFramesLoaded) {
                                clearInterval(checkInterval); 
                                loadingMsg.remove();
                                playAnimationSequence(frames);
                            }
                        }, 500);
                    }
                    isClicked = true;
                }
            });
            
            window.addEventListener('resize', createArrows);
        });
    </script>
</body>
</html>
